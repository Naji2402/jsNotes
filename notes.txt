FIXME: SECTIONS
TODO: MAIN TOPICS

SECTION 14: OBJECT ORIENTED PROGRAMMING(OOP) FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:

TODO:. .Classes are just 'Syntactic sugar' over constructor funtions.
       .Classes are not hoisted.
       .Classes are first class citizens.
       .Class body is always executed in strict mode. 

TODO:. There are 4 fundamental OOP principles.
        1) Abstraction:
                .abstraction means ignoring or hiding details that don't matter, allowing us too get an overview perspective of the the thing we're implementing.
        2) Encapsulation:
                .encapsulation means keeping properties and methods private inside the class, so they are not accessible from outside the class.
                 some methods can be exposed as a public interface (API).
        3) Inheritance:
                .inheritance makes all properties and methods of a certain class available to a child class, forming a hierarchical relationship between classes.
                 this allows us to reuse commom logic and to model real-worlds relationships.
        4) Polymorphism:
                .polymorphism means that a child class can overwrite a method it inherited froma parent class. 
                
TODO:. In javascript there is something called prototypes.
        .all objects are linked to a prototype object.
     . Prototypal inheritance:
                .it means all objects that are linked to a prototype object can use the methods and properties that are defined on that prototype.
                .the prototype contain methods that are accessible to all objects linked to that prototype;

TODO:. There are 3 ways of implementing prototypal inheritance in javascript.
        1) Constructor funcions.
                .Technique to create objects from a function.
                .This is how built-in object like Arrays, Maps or Sets are actually implemented.
                .eg(
                        const Person = function (firstName, birthYear) {
                                this.firstName = firstName;
                                this.birthYear = birthYear;
                        }

                        const jonas = new Person('Jonas', 1991);
                )
                .when we call any function with the new operator
                        .an empty object is created.
                        .this keyword in constructor funcion call is set to the new object.
                        .the new object is liked(__proto__property)to the constructors funcion's prototype property.
                        .the new object is retuned from the constructor funcion call.

        2) ES6 Classes.
                .Modern alternative to constructor funcion syntax.
                ."Syntacis sugar":behind the scenes, ES6 classes work exactly like constructor funcions.
                .ES6 classes do not behave like classes in 'classical OOP'.
                .eg(
                        class PersonCl {
                                constructor(firstName, birthYear) {
                                        this.firstName = firstName;
                                        this.birthYear = birthYear;
                                }

                                calcAge() {
                                        console.log(2037 - this.birthYear);
                                }
                        }

                        const jessica = new PersonCl('Jessica', 1996);
                )
        3) Object.create().
                .The easiest and most straightforward way of linking an object to prototype object.
                .eg(
                        const PersonProto = {
                                calcAge() {
                                        console.log(2037 - this.birthYear);
                                },
                        }
                        const steven = Object.create(PersonProto);
                )

TODO:. 1) In javascript classes are not hoisted.
       2) classes are also first-class citizens.
       3) classes are executed in strict mode .

TODO:. Every object in javascript can have getter and setter property.
        they are basically funcions that get's and set's value.

TODO:. Inheritance between classes.
     . eg(

        class PersonCl {
         constructor(fullName, birthYear){
                this.fullName = fullName;
                this.birthYear = birthYear
         }

                calcAge() {
                        console.log(2037 - this.birthYear);
                }

                greet() {
                        console.log(`Hey ${this.fullName}`);
                }

                get age() {
                        return 2037 - this.birthYear;;
                }

                set fullName(name) {
                        if (name.includes(' ')) this._fullName = name ;
                        else alert(`${name} is not a full name`)
                }

                get fullName() {
                        return this._fullName;
                }

                static hey() {
                        console.log('Hey there');
                        console.log(this);
                }
        }

        class StudentCl extends PersonCl {
             constructor(fullName, birthYear, course) {
                  super(fullName, birthYear);
                  this.course = course;
             }
        }
     )
     .in this example the StudentCl is the child class and the PersonCl is the parent class.
     .by using the extends keyword the child class(StudentCl) will inherit the methods and properties of parent class(PersonCl).
     .The super keyword in the constructor will call the constructor of the parent class. 
     .the superkeyword is necessory to ensrue that the parent class's properties and methods are correctly initialized before the child class's own constructor logic is executed.

TODO:. Fields and methods related to encapsulation.
          1). Public fields:
                .we can think of field as a property that will be on all class instances.
                .eg(
                        class Account {
                                locale = navigator.language;
                                bank = 'Bankist';
                                
                                constructor(owner, currency, pin) {
                                        this.owner = owner;
                                        this.currency = currency;
                                        this.pin = pin;
                                        this.movements = [];
                                        console.log(`Thanks for opening an account ${owner}`);
                                }
                        }
                ) in this example the locale and the bank are public fields.
          2). Private fields:
                .eg(
                        class Account {
                                locale = navigator.language;
                                bank = 'Bankist';
                                #movements = [];
                                #pin;

                                constructor(owner, currency, pin) {
                                        this.owner = owner;
                                        this.currency = currency;
                                        this.#pin = pin;
                                        console.log(`Thanks for opening an account ${owner}`);
                                }
                        }
                ) in this example the movements and the pin is a private field and it can only be accessed from inside the class.
                   if we try to access it from the outside of the class we will get an error.
          3). Public methods:
                .eg(
                        class Account {
                                locale = navigator.language;
                                bank = 'Bankist';
                                #movements = [];
                                #pin;

                                constructor(owner, currency, pin) {
                                        this.owner = owner;
                                        this.currency = currency;
                                        this.#pin = pin;
                                        console.log(`Thanks for opening an account ${owner}`);
                                }

                                getMovements() {
                                        return this.#movements;
                                }
                                
                                deposit(val) {
                                        this.#movements.push(val)
                                }
                                
                                withdraw(val) {
                                        this.deposit(-val)
                                }
                                
                                approveLoan(val) {
                                        return true;
                                }
                                
                                requestLoan(val) {
                                        if (this.approveLoan(val)) {
                                        this.deposit(val);
                                        console.log('Loan approved');
                                        }
                                }
                        }
                ) in this example all the methods(deposit, withdraw, approveLoan, requestLoan) is a public method.
                    they are part of the public interface(API).
          4). Private methods:
                .eg(
                        class Account {
                                locale = navigator.language;
                                bank = 'Bankist';
                                #movements = [];
                                #pin;

                                constructor(owner, currency, pin) {
                                        this.owner = owner;
                                        this.currency = currency;
                                        this.#pin = pin;
                                        console.log(`Thanks for opening an account ${owner}`);
                                }
                                
                                deposit(val) {
                                        this.#movements.push(val)
                                }
                                
                                withdraw(val) {
                                        this.deposit(-val)
                                }
                                
                                #approveLoan(val) {
                                        return true;
                                }
                                
                                requestLoan(val) {
                                        if (this.approveLoan(val)) {
                                        this.deposit(val);
                                        console.log('Loan approved');
                                        }
                                }
                        }
                )in this the approveLoan method is private.it cannot be accessed from the outside.
          5). Static version of the 4 above.
                .static fields and static methods are not accessible on the instances.
                .they are only accessible on the class itself
                .just use the static keyword in front of the fields and methods.
TODO:. 

SECTION 13: ADVANCED DOM AND EVENTS FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:

TODO:. To implement scrolling on the website use window.scrollTo method.
        it enable us to scroll to a specific set of coordinates within the browser window.
     .syntax( 
        .window.scrollTo(xCoord, yCoord)
        .window.scrollTo(options)
           options is an object contains properties to define the scroll behaviour.
           left, top, behaviour: 'smooth', 'instant', 'auto'
      )
      .eg(
        window.scrollTo(0, 200) //scroll the page to a position 200 pixel from the top and 0 pixel from the left
        window.scrollTo({
                top: 500,
                left: 0,
                behaviour: 'smooth'
        }) // scroll the page to a poistion 500px from the top, 0 from the left and with a smooth behaviour;
      )

TODO:. scrollIntoView method is another method to implement scrolling.
     .syntax(
           element.scrollIntoView(options) //scrolls to the element defined in front of the method.
      )
     .eg(
        element.scrollIntoView({behaviour: 'smooth'}) //scrolls to the element definded in front of the method is a smooth behavior.
     )

TODO:. getBoundingClientRect is a javascript method that returns the size of an element and its position relative to the viewport(the visible area of the browser window) .
        it tells you where an element is on the screen and how big is it, relative to what the user sees right now.
     .syntax(
        element.getBoundingClientRect();
     )
     .eg(
        const rect = element.getBoundingClientRect(); //returns a object containing numberic properties
        //output {
                x: 20,
                y: 100,
                width: 200,
                height: 80,
                top: 100,
                right: 220,
                bottom: 180,
                left: 20
        }   
     )

TODO:. The pageXOffset and pageYOffset are properties that tell you how far the page has been scrolled.
        they measure scroll distance relative to the top-left corner of the document.
        it give how many pixels yoy have scrolled from the top and right.
      . eg (
        window.pageXOffset // the output will be 0
        window.pageYOffset // the outut will be 350
      )  

TODO:. Event propagation in javascript describes how an event travels through the DOM from the moment its triggered until it finishes 
     . In javascript, when an event occurs(like a click), it does'nt just fire on the element you clicked.
        it goes throught three phases.
                1. Caturing phase
                        Event travels from the window > document > body > parent > elements > target element
                2. Target phase 
                        Event reaches the actual element clicked.
                3. Bubbling Phase(Event Bubble)
                        Event travels back up from the targer > its parents > up to the document > window         

TODO:. The getAttibute() in javascript is a method used to read the value of an attribute from an HTML element.
          it retreives the string value of an attribute exactly as it appears in the HTML   
     . syntax(
        element.getAttibute(attributeName);
     )  
     . eg(
        <div id='box' date-info="hello"></div>
        const div = document.getElementById("box");
        console.log(div.getAttibute("id")) // "box"
        console.log(div.getAttibute("data-info")) // "hello"
     )   

TODO:. DOM traversing in javascript refers to the process of navigating the DOM to access and maniplate the elements within an HTML document.
        This allow you to move between the nodes, exploring their relationships and finding specific elements

TODO:. The closest method in javascript is a way to traverse the DOM tree upwards from a given element.
        searching for the nearest ancester or the element that matches a specified css selector
     . eg(
        element.closest('.header') // returns the closest element from the elements that has a class named header.
     )   

TODO:. The Intersection Observer API provides a way to observe changes in the intersection target elements with an root element or with the document's viewport.
         .target element is the DOM element to observe for intersection changes.
         .root is the element that the target is intersecting.
             we can set it to an element. setting it into null will enable the intersecting to the viewport. that is the viewport will be the root element.
         .threshold is the percentage of intersection at which the callback funcion will be called. (it is basically when how much percentage of the element displayed in the screen and then call the callback function.)
         .rootMargin is will the the value given to the outside of the targer element(eg '90px' , 90px to the outside of the target element)
     . The callback funcion will  get called each time the target element is intersecting the root element at the threshold that we defined
     .the callback function will get passed a entries and observer 
        the entries passed to the callback contains     
                        .entry.targer
                        .entry.isIntersecting
                        .entry.intersectionRation
                        .entry.getBoundingClientRect
                        .entry.intersectionRect
                        .entry.rootBounds
     . syntax(
        new intersectionObserver(<callBack funcion>, <options>)
        options can contain, root, threshold.
        eg(
                const options = {
                        root: null, 
                        threshold: 0.1,
                        rootMargin: '90px'
                }

                funcion callback(entries, observer) {
                        console.log(entries)
                }

        )
     )   
     .eg(
        const obsCallback = function (entries, observer) {

        entries.forEach(entry => {
                console.log(entry);
        })
        };

        const observerOptions = {
                root: null,
                threshold: 0.1,
        };

        const observer = new IntersectionObserver(obsCallback, observerOptions);
        observer.observe(<element>);

     )


SECTION 12: NUMBERS, DATES, INTI, TIMERS FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:

TODO:. Type conversion and Coercion Refer to the process of changing a value from one data type to another.
        *Type conversion
                .Type conversion is when the developer manually convert a value from one type to another using built in function or constructors.
                .The developer is manually instructing the javascript to perform the conversion.
                .eg( 
                    let strNum = '123';
                    let num = Number(strNum); //num is now 123 (number)   ;

                    let myNum = 42;
                    let str = String(myNum); //str is now "42" (string);  
                )
        *Type Coercion
                .Type Coercion happens automatically by the javascript engine.
                .this happens when an operation involves values of different data types.
                .JS implicitly convert one or more values to a compatible type to perform the operation.
                .eg( 
                     let result1 = "5" - 2; // "5" is coerced to 5, result1 is 3 (number)
                     let result2 = "Hello " + 10; // 10 is coerced to "10", result2 is "Hello 10" (string)
                     if("abc"){
                        // "abc" is coerced to true (boolean)
                        console.log("This will execute. ");
                     }
                     let isEqual = 5 == "5" // "5" is coerced to 5, isEqual is true (boolean)

                )

TODO:. Intl.DateTimeFormat constructor in javascript is an API used to create objects that enable language-sensitive date and time formatting.
        this allow us to display dates and times in a way that is appropriate for a specific locale,
     . syntax ( new Intl.DateTimeFormat(locales, options).formate(<what to formate(date)>)).
     . to get locale from the user 
          const locale = navigator.language // give the users locale.
     . eg ( 
        const now  = new Date();
        const options = {
                hour: 'numeric',
                minute: 'numeric',
                day: 'numeric',
                month: 'long',
                year: 'numeric',
                weekday: 'long'
        }

        new Intl.DateTimeFormat('en-US').format(now) // give the current time and date based on english in United states.
        new Intl.DateTimeFormat('ar-SY').format(now) // give the current time as date based on arabic in Syria.

        new Intl.DateTimeFormat('en-US', options).format(now) // gives the current time and date based on the locale and options we passed to Inl Api
        new Intl.DateTimeFormat('ar-SY', options).format(now) // gives the current time and date based on the locale and options we passed to Inl Api
       )

TODO:. Intl.NumberFormat constructor in js is an API used to create language-sensitive number formating.
        similat to Intl.DateTimeFormat it accepts an locale and options.
     . syntax ( new Intl.NumberFormat(locale, options).format(<what to format>))
     . eg(
        const num = 3884764.23;
        const options = {
                style: "currency",
                currency: 'INR',
                ....,
                ....,
                ....
        }
        new Intl.NumberFormat('en-IN', options).format(num) // formats the number based on the locale and options provided into the Intl.NumberFormat.
        // output: â‚¹38,84,764.23
     )   
     .more options are available.


SECTION 11: WORKING WITH ARRAYS FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:

TODO:. The slice method returns a copy of an array into a new array.
        The original array will not be modified.
     . eg( const animals = ['ant', 'bison', 'camel', 'duck', 'elephant']
            console.log(animals.slice(2, 5)) // ['camel', 'duck']
            console.log(animals) // ['ant', 'bison', 'camel', 'duck', 'elephant']
        )

TODO:. The splice method is used to change the contents of an array by removing or replacing existing elements .
        it directly modifies the original array and returns an array conaining the deleted elements.
     . splice(1, 2) in this 1 is the starting index and 2 is how many elements should be removed from the starting index.
     . eg( let fruits = ['apple', 'banana', 'cherry', 'date']
           let removed = fruits.splice(1, 2) //Fruits is now ['apple', 'date']
           // removedFruits is ['banana', 'cherry']
     )

TODO:. insertAdjacentHTML method is used to add html elemets via javascript.
        It is similar to innerHTML.
        insertAdjacentHTML takes two parameters.
            *first parameter is where to add there are four types(afterbegin,beforebegin, beforeend, afterend).
            *second parameter is what html we need to insert into the element.
        eg( body.insertAdjacentHTML('afterbegin', html) ), 
            where afterbegin is where to add the element and the html is the html code we want to insert into to body element.

TODO:. find method is an array method used to loop through the array and returns the first value that satisfies a specific condition.
         if no elements matches the condition it returns undefined.
       .eg ( arra.find((element) => {
            return element.name === 'Messi';
        }));
         returns the first element that has the name property equal to Messi.

TODO:. findIndex method in an array is used to loop through an array and returns the index of the first element that satisfies a specific condition.
        if no element mathches the condition it returns undefined.
     . eg( arr.findIndex((element) => {
        return element.name === 'Messi';
     }));
        returns the first element that has  the name property equal to Messi.

TODO:. The object.groupby method in js loops throug an iterable like an array and turns it into an object according to the string values returned from a callback function.
     .  eg( let variable = Object.groupBy(array, (a) => {
            return a > 0 ? 'first' : 'second'
       }) )
       This retuns an Object with two keys named first and second.The first and second will be an array. the first array will have the positive values and the other will have the negative values. 
     . eg( const groupedAccount = Object.groupBy(array, (arr) => acc.type) )
         this will make a new object and group it int arrays based on the type of the objects.

TODO:. The toReversed method is used to reverse an array without mutating the original array.
        unlike reverse method toReversed method does not change the original array.
     . eg( arr.toReversed() )
        this will take a copy of the arr array and reverse the array.
     . SIMILAR( ( toReversed(), reverse() ), (toSorted(), sort() ), ( toSpliced(), splice() ))
        these are the other method similar to the toReversed method.

TODO:. Which array method to use.
            * To Mutate the original array.
                    .push(), pop(), shift(), unshift(), splice(), reverse(), sort(), fill();
            * Non destructive versions of reverse(), sort(), splice().
                    .toReversed(), .toSorted(), .toSpliced()
            * To make a new array based on the original.
                    .map(), filter(), slice(), with(), flat(), flatMap(), concat().
            * To get an index.
                    .indexOf(), findIndex(), findLastIndex().
            * To get an array element.
                    .find(), findLast();
            * Know if array includes.
                    .includes(), some(), every();
            * transform array to a new string.
                    .join()
            * To transform an array to a single value.
                     .reduce()
            * To loop through an array.
                    .forEach()

SECTION 10: FUNCTIONS FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:FIXME:

TODO: .Js Does not have passing by reference. 
    The reference that we pass pass is a value.
    It is a value that contains a memmory address. 
    Basically we pass a referece to the funcion but we do not pass by a referece.


TODO:. Js has first class funcion it enable us to write Higher order functions.

    *first class functions
        .Treats functions as first class citizens
        .This means that function are simply treated as values
        .Function are just another type of object in js.
        .functions are values too
        .can pass functions as arguments to other functions.
        .eg (bind())
    
    *Higher order functions
        .A function that receives another function as an argument, that returns a new function, or both
        .this is only possible because of first class function.
        .eg (addEventListener())

TODO:. Advantages of callBack function

        .allow us to split up to code to reusable codes.
        .(imp) callBack functions allow us to create abstraction.
    

TODO:. The this keyword depends on how the function is called.
        .if the function is called by the object (eg jonas.book()),
            the this keyword points to the jonas object.
        .if the function is called not by the object (eg: the book method is stored outside in a varible),
            then the this keyword points to undefined.

        *How to tell js what the this keyword should look like. using 
            *call():
                    .call(<this keyword>, <rest of the parameters>)
                    .we call the call method first and then the call method calls the funcion
                          with the this keyword set to the first argument we pass in the call method.
                    .eg( book.call(jonas, 23, 'Jonas Schmedtmann) ). 
                          jonas is the this keyword and the rest of the arguments is like normal arguments.
            *apply():
                    .apply method does not receives arguments after the this keyword like call method
                    .it take an array of arguments.
                    .not used in modern js. better is call method;
                    .eg( bood.apply(jonas, flightData) ). flightData is an array. jonas is this keyword
            *bind(): 
                    .bind method does not immediatly call the function.
                    .instead it returns a new funtion where the this keyword is whatever the values we pass into the bind.
                    .eg( const bookEw = book.bind(eurowings)
                         bookEw(23, 'steven Williams')). 
                    the bind method returned a funtion,
                    and it is stored in bookEw variable . 
                    where the bookEw has the eurowings bound as the this keyword.


TODO:. In closure a function has access to the variable enviornment of the execution context in which the functiion was created,
        even after that execution context is finished executing.
    .A closure is the closed over variable enviornment of the execution context in  which a funcion was created, 
        even after that execution context is gone.
    .A closure give a function access to all the variable of its parent function , even after that parent function has returned.
        the function keeps reference to its outer scope, which preserves the scope chain throughout time.

