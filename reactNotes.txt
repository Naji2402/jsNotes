MAIN TOPICS: 
SUB TOPICS : 

CODEEVOLUTION NOTES 

. Rules of hooks
        .Only call Hooks at the Top Level.
            Don't call Hooks inside loops, conditions, or nested functions.
        .Only Call Hooks from React functions.
            Call them from within React functional components and not just any regular javascript function.
    
 useReducer():
            .useReducer is a a react hook that is used for state management.
            .it is an alternative to useState hook.
            .useState is built using useReducer.
            .useReducer is similar to the reduce method of javascript.
            .syntax(

                //Reduce is javascript
                    array.reduce(reducer function, initialValue)
                    singleValue = reducer(accumulator, itemValue) //return a single value



                //useReducer in React
                    useReducer(reducer function, initialState)
                    newState = reducer(currentState, action) //return a pair of values. [newState,  dispatch]
            )
            .WHEN TO USE
                        ---------------------------------------------------------------
                       | Scenario        |        useState           |      useReducer  |
                        ---------------------------------------------------------------
                        .Type of state   | .Number,string, Boolean  | .Object or Array       
                        .No of state     | .One or two              | .Too many
                            transitions  |                          |
                        .Related state   | .No                      | .Yes
                            transitions  |                          |
                        .Business logic  | .No business logic       | .Complex business logic
                        .Local vs Global | .Local                   | .Global   
            .eg(
                const initialState = 0;

                function reducer(state, action) {
                switch(action){
                    case 'increment':
                        return state + 1
                    case 'decrement':
                        return state - 1
                    case 'reset':
                        return initialState
                    default:
                        return state
                }
                }

                function MyComponent() {
                
                const [count, dispatch] = useReducer(reducer, initialState)

                return (
                    <>
                    <div>
                        <div>Count - {count}</div>
                        <button onClick={() => dispatch('increment')}>Increment</button>
                        <button onClick={() => dispatch('decrement')}>Decrement</button>
                        <button onClick={() => dispatch('reset')}>Reset</button>
                    </div>
                    </>
                );
                }
            )

. REACT ROUTER:
            . To setup React Router install the react router package using the command npm install react-router-dom@latest.
            . in the main.jsx file import BrowserRouter from react-roter-dom, then wrap the App component inside the BrowserRouter.
            . in the App component file import Routes and Route from react-router-dom.
            . after importing inside the return jsx of App component, open a Routes component.
            . within the Routes component we define the individual routes using the Route component.
            . on the route component we specify two props.
                1) path: the Path in the url.
                2) element: when the url matches the path this element will be rendered.
                    eg( <Route path="/" element={<Home />}></Route> ) // when the url mathces the / path the Home component will be rendered.

. REACT ROUTER LINKS:
                .to navigate to different routes using elements in the UI.
                .import the Link from react-router-dom package.
                .after import instead of using the anchor tag(<a href="#"></a>) use the Link component.
                .the link component will be automaticaly converted into anchor tag, while we inspect the page.
                .the Link component accept a parameter of to where you give the path.
                    eg(  
                        <Link to='/'>Home</Link>
                        <Link to='/about'>About</Link>
                    )
                .after that import it into the app component
                    eg(
                        <NavBar />
                        <Routes>
                            <Route path="/" element={<Home />}></Route>
                            <Route path="about" element={<About />}></Route>
                        </Routes>
                    )

. There is also another link component in the react-router-dom called NavLink
     . The NavLink  component is similar to the Link component.
     . The difference is that the NavLink by default it receives an active class when the link is the current route.
     . we can use the class active to style it.
     . eg(
        nav a.active{
            text-decoration: none;
            font-weight: bold;
        }
     )
                
. useNavigate()
            . the useNavigate hook is a react hook that is used to navigate programatically.
            . first import it from the react-router-dom package.
            . after importing invoke the hook inside the component and store it into a varibale.
            . we can now use the varible to programatically navigate.
            . on a button click we can pass the navigate and pass the path as parameter inside the navigate.
            . we can also implement the back button using the use navigate hook.
            . eg(
                import { useNavigate } from "react-router-dom";

                function Home() {
                 const navigate = useNavigate();
                    return(
                        <>
                            <div>Home Page</div>
                            <button onClick={() => navigate('path to the page')}>Go to next page</button>
                        </>
                    )
                }

                // implementing back button
                 <button onClick={() => navigate(-1)}>Go back</button>
                 this will navigate back to the previous route.

            )

. No Match Route.
            . No Match route is used when no path find match with the URL.
            . We can create a NoMatch component and render it when no match is found in the path.
            . add a new Route in the App.js and set the path of it to a * and element as the NoMatch component.
            . the * has a special meaning in React. it will match route only when no other route matches.
            . eg(
                <Route path="*" element={<NoMatch />}></Route>
                when no other route matches this route will render the NoMatch component.
             )

. Nested Routes.
            . Nested Routes is a way to orgainze routes where a parent route controls the layout and a portion of the UI for its child routes.
            . This allows to update only specific sections of a page.
            . However to render the child routes we need to use the Outlet that is imported from react router dom. use it where you need the child components to render.
            . eg (
                <Route path="products" element={<Products />}>
                    <Route path="featured" element={<FeaturedProducts />}></Route>
                    <Route path="new" element={<NewProducts />}></Route>
                </Route>

                // in this exapmple the parent route is products and the child routes is featured and new.
                   while routing to the child routes the path on the url will look like localhost:5173/products/featured, localhost:5173/products/new.
            )

. Index Route.
            . Index Route is a special child route like nested route that renders by default when the user visit the parent Route.
            . it acts as a default view or landing page for that section.
            . instead of the path is receives a index parameter and element parameter.
            . the index parameter will use the path of the parent element.
            . eg(
                <Route path="products" element={<Products />}>
                    <Route index element={<FeaturedProducts />}></Route>
                    <Route path="featured" element={<FeaturedProducts />}></Route>
                    <Route path="new" element={<NewProducts />}></Route>
                </Route>

                // in this exapmple when the user goes to the parent products route the FeaturedProducts route will be also rendered default,
                    because we defined it as a index route.

            )

. Dynamic Route.
            . Dynamic Route is a method for creating flexible, data-driven pages using a single route configuration, rather than defining a seperate, state, route for every possible URL.
            . eg (
                <Route path="users/:userId" element={<UserDetails />}></Route>

                // in this example whe the URl is users/anything it it will search if there is any routes with fixed element with a fixed path, 
                    if there is it will render that element in the given path,
                    if there is not then ther UserDetails element is rendered. 
            )


. useParams hook allows to access dynamic parameter from the current URL
        . first import useParams from react-router-dom.
        . after importing invoke it inside the component and store it in a variable.
        . eg(
            const params = useParams(); // this will return a object with a userId property, because we set the dynamic route as userId.
            const userId = params.userId; // extract the userId from the object.
        )
            
 . useSearchParams():
            . the useSearchParams is a react hook similar to the useState hook, instead of storing the state in memory the useSearchParams store in the URL.
            . import it from react-router-dom and invoke it inside the component.
            . useSearchParams return two values, a object and a function to set the searchParams.
            . using the function we can add or remove parameter
            . to get hold of the parameter we use the get method on the value returned. eg( const val = value.get(<param name>));
            . eg(
                const [searchParams, setSearchParams] = useSearchParams();

                <button onClick={() => setSearchParams({ filter: 'active'})}>Active</button> // while clicking the URL will look like localhost:3000/users/filter=active. added a parameter
                <button onClick={() => setSearchParams({})}>Reset</button> // while clicking the parameter is reseted. localhost:3000/users

                const showActiveUsers = searchParams.get('filter') // now we can check if it is acive using this variable.

                //
            )


BROCODE NOTES 

. REACT COMPONENT STYLING.
    .There are 3 ways to style a react component with css.
        1). External.
                .creating a external css file and importing to the jsx file.
        2). Modules.
                .recommended way of styling.
                .create a folder for the component and create a module css file and import.
                .eg Button > Button.jsx, Button.module.css 
        3). Inline.
                .create an object inside the component itself and put it inside the component.
                .eg(
                    function Button() {
                        const styles = {
                            backgroundColor: " hsl(200, 100%, 50%)",
                            color: "white",
                            padding: "10px 20px",
                            borderRadius: "5px",
                            border: "none",
                            cursor: "pointer",
                        };
                        
                        return (
                            <>
                            <button style={styles}>Click Me</button>
                            </>
                        );
                    }
                )
            
. PROPS
        . props are read-only properties that are shared between components.
        . a parent component can send data to a child component.
        . in order for a component to accept props the component function needs a props parameter.
        . the props parameter is goint to be a javascript object.
        . in order to use the key value that we passes from the parent we use the props.key
            eg( 

                function App() {
                    return(
                        <>
                            <Student name='SpongeBob' age={30} isStudent={true}/>
                        </>
                    );
                }

                function Student(props){
                    return(
                        <p>Name: {props.name}</p>
                        <p>Age: {props.age}</p>
                        <p>Student: {props.isStudent ? 'Yes' : 'No'}</p>
                    );
                }
            )

    .. defaultProps
                . defaultProps are default values for props in case they are not passed from the parent component.
                . eg(
                    import Student from "./Student";

                    function App() {
                        return(
                            <>
                                <Student />
                            </>
                        );
                    }


                    function Student({name = 'Guest', age=0, isStudent=false}) {
                        return(
                            <>
                            <div className="student">
                                <p>Name: {name}</p>
                                <p>Age: {age}</p>
                                <p>Student: {isStudent ? 'Yes' : 'No'}</p>
                            </div>
                            </>
                        );
                    }
                )

. Conditional Rendering.
             . Conditional Rendering allows us to control what gets rendered in the application based on certain conditions.
             . (show, hide, or change components).
             .eg(
                function App() {
                    return(
                        <>
                        <UserGreeting isLoggedIn ={true} username = 'Lionel Messi' />

                        </>
                    );
                }

                function UserGreeting(props) {
                    if (props.isLoggedIn) {
                        return(
                            <h2>Welcome {props.username}</h2>
                        )
                    }else {
                        return(
                        <h2>Please log in to continue</h2>
                        )
                    }
                }
             )

. React hooks.
            .React hooks are special functions that allows functional components to use React features without writing class components.
            .useState, useEffect, useContext, useReducer, useCallback, and more.

    . useState():
                . useState is a react hook that allows the creating of a stateful varible and a setter function to update its value in the virtual DOM.
                . the useState hook return the value and a setter function
                . the setter function is used to change the value. if we dont use the setter function the component won't re render and the dom wont update.
                . let [name, setName] = useState(); in this the name is the value and the setName is the setter function.
                        to change the name we need to use the setName setter function.
                        setName("Neymar") this will cause the component to re render and the name will be updated to Neymar, updates will be reflected in the dom.
                . The useState hook also has a updater function. it is a function passed as as argument to the setter function.
                    it allow for safe updates based on the previous state used with multiple statte updates and synchronous functions.
                    setName(prevName => prevName + 'Bye' )

                .eg(

                    let [name, setName] = useState();
                    // to change the name we need to use the setter function ie setName.
                    setName("Messi") // this will cause a re render of the component and change the dom. 
                                if we try to normally change the name name="messi" it wil not cause a re render and the dom won't be updated
                )
    . useEffect():
                . useEffect is a react hook that tells React Do some code when 
                    This component re-renders
                    This component mounts
                    The state of a value
                .useEffect(function, [dependencies])
                    .useEffect(() => {})           //Runs after every re-render.
                    .useEffect(() => {}, [])       //Runs only on mount.
                    .useEffect(() => {}, [value])  //Runs on mount + when value changes
                .USES
                    .#1 Event Listeners.
                    .#2 DOM manipulation.
                    .#3 Subsciptions (real-time updates).
                    .#4 Fetching Data from an API.
                    .#5 Clean up when a component unmounts.
                .the useEffect hook also has a cleanup function.
                    when we return a function inside the useEffect hook it is a cleanup function.
                    the cleanup function will execute when the component unmounts(when removed)
                    eg(
                        useEffect(() => {

                            return () => {

                            } //cleanup function, run when the component unmounts.
                        })
                    )
                .eg(
                    const [count, setCount] = useState(0);

                    useEffect(() => {
                        document.title = `Count ${count}`
                    }, [count]) 

                    .every time the count change the function will run.
                    .if the dependencies array was empty [] the function will run only once when the component mount(when its added to the dom).
                    .if there is no dependencies array the function will run after each re render of the component.
                )

    . useContext():
                . useContext hook is a react hook that allows you to share values between multiple levels of components without passing props through each level.
                . it provides a way to pass data through the component tree without having to pass props down manually at every level.
                .PROVIDER COMPONENT:
                    1). import {createContext} from 'react';
                    2). export const MyContext = createContext();
                    3). <MyContext.Provider value={value}>
                            <Child />
                        <MyContext.Provider>
                .CONSUMER COMPONENT:
                    1). import React, { useContext } from 'react';
                        import { MyContext } from '<provider component>'
                    2). const value = useContext(MyContext)

                    

    . useRef():
                .UseRef hook is a  react hook. "use Reference" Does not cause re-renders when its value changes. when you want a component to "remember" some information,
                    but you don't want that information to trigger new renders.
                .useRef returns a object.
                    the object will look like {current: initialValue}
                .USES:
                    1). Accessing / Interacting with DOM elements.
                    2). Handling Focus, Animations, and Transitions.
                    3). Managing Timers and Intervals.
                .eg(
                    const ref = useRef(0);

                    //The object looks like: { current: 0}

                    function handleClick() {
                        ref.current++;
                        console.log(ref.current);
                    }

                    //this will increase the initialValue on each click but does not re render the component.
                )
                    